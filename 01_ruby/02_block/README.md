Block
===

Rubyの、他の言語と比べて特徴的な機能であるブロックについてお話します。

# Rubyにおける主なブロックの利用方法

Rubyで最も利用されるブロックの使い方は、Enumrableモジュールに定義されているメソッドたちの引数としてです。Enumrableモジュールには、次のようなメソッドが定義されています。

```
each
filter
include?
map
reduce
```

これらは、Rubyを書く上で最も頻繁に使われると思う、ブロックを引数とするメソッドたちです。
他にも様々なメソッドがあるので、このリファレンスを眺めてください。
[module Enumerable](https://docs.ruby-lang.org/ja/latest/class/Enumerable.html)

Enumerableモジュールは、Rubyにおいて繰り返し計算が可能なクラスにMix-inされているモジュールです。例えば、ArrayやHashなど、複数の要素を連続的に扱うクラスです。
Rubyにおいて、配列やハッシュの要素にアクセスするために、次のような文法を用いることはほとんどありません。

```ruby
arr = [1, 2, 3, 4, 5]

while i < arr.length
  puts arr[i]
  i += 1
end

for i in arr
  puts i
end
```

whileはCやJavaScriptのようなスタイル、forはPythonやShellのようなスタイルです。この二つはどちらも同じ様に配列のすべての要素を出力しますが、Rubyでは通常次のように書かれます。

```ruby
arr = [1, 2, 3, 4, 5]

arr.each do |i|
  puts i
end
```

eachは、反復可能なイテレーターを利用する書き方です。添字を加算してく方法で配列にアクセスすることは、Rubyでは基本的にありえません。
しかし、繰り返し処理を書く上で、稀に添字が必要になることもあります。例えば、偶数の要素だけになにか変化を加えたい、などのケースです。
その場合、Rubyには反復処理時に添字を一緒に受け取る方法を提供しています。

```ruby
arr = [1, 2, 3, 4, 5]

arr.each_with_index do |num, i|
  puts i % 2 == 0 ? num * 2 : num
end
```

このコードは、配列の要素をすべて出力しますが、添字が2の倍数のときだけは数字を2倍にして表示します。

# ブロックを使った、Rubyでよくあるコード

##  ファイル

ファイルを開いて操作する場合にも、ブロックを使用します。

```ruby
File.open('path/to/file', 'a') do |f|
  f.puts("something")
end
```

ブロックを使用するメリットは、ファイルハンドラである `|f|` の管理をFileモジュールがやってくれるというものがあります。
`File.open` は、ブロックを取らずに書くことも可能ですが、この場合はハンドラのクローズなどをユーザーが行わなくてはならないので、特別な理由がない限りはブロックを用いましょう。

```ruby
f = File.open('path/to/file', 'r')
line = f.readline
f.close
```

最後にクローズ処理を忘れると、fが生き続けている限りハンドラが開かれたままになり、リソースの無駄です。このような事故を防ぐために、かならずFileはブロックと一緒に使いましょう。
また余談ですが、ファイルの中身を全部読み込むだけであれば、ブロックは必要ありません。

```ruby
# ファイルの中身をすべて読み込み、改行で分割する
lines = File.read('path/to/file').split("\n")
```

## ActiveRecordのトランザクション

かなり雑な例ですが、お金と商品を引き換えにするような場合には、RDBMSのトランザクションを使う必要があります

```ruby
ActiveRecord::Base.transaction do
  u = User.find_by(name: 'ppyd')
  if u.account.total >= 10000
    u.account.total -= 10000
    u.inventories.create!(name: 'something', price: 1000)
  end
end
```

このように、ブロックは一つのまとまった処理として表現され、その前準備と後始末をメソッド側に任せたい場合などに使われるケースが多いです。

# ブロックはクロージャ

> 参考 : かんたんRuby 2-24 P78

ブロックは、極端に説明するとクロージャを作成するための専用構文です。他の言語における、無名関数や即時関数という表現に近いです。
一般的な書き方は、メソッド呼び出しの時に `{}` か `do ~ end` でコードを囲って記述します。通常の場合は、 `do ~ end` で書きますが、メソッドチェインをする場合と一行で書ききれる場合には `{}` を用いることが多いです

```ruby
# 一行で書けるとき
[1, 2, 3].map { |n| n * 3 }

# メソッドチェインするとき
[1, 2, 3, 4, 5, 6, 7].select { |n
  mod = n % 3
  mod == 2
}.map { |n| n * 3 }
```

クロージャは、スコープを保持したままコードブロックを持ち出す仕組みです。ブロックはあくまでメソッドの引数なので、ブロックが処理されるのは呼び出した先のメソッドの中のコンテキストです。
しかし、クロージャなのでブロックはコードが記述された場所のコンテキストを保持します。

```ruby

hoge = "foo"

["hoge", "foo", "piyo"].each do |word|
  puts "match!" if word == hoge # hogeにアクセスできるが、本当はeachメソッドで評価されているので触れないはず。つまり、ブロックはクロージャ。
end
```

注意点として、稀にコンテキストを変更して実行されるブロックも存在するので、厳密には完全なクロージャではありません。ですが、基本的にはクロージャとして覚えれば問題ないと思います。
次に、ブロックを受けるメソッドの定義です。

```ruby
def triple(arg, &blk)
  acc = arg
  3.times { acc = blk.call(acc) }
  acc
end
```

特に何の意味もないですが、第一引数に対して受け取ったブロックを三回実行するメソッドです。このメソッドを利用するには、次のように書きます。

```ruby
triple(1) do |n|
  n + 1
end
# => 4
```

動作を解説すると、tripleはまず第一引数をaccという変数に格納し、それを引数にブロックを実行し、そしてその戻り値を再びaccに代入する、という動作を3回繰り返します。

この例を見てわかるように、 `do ~ end` で囲まれたブロックは、tripleメソッドの引数では `&blk` という表記で表されています。 `&` は、ブロックとして引数を受け取るという宣言で、変数名は `blk` です。

`&` を付けて受け取ったブロックは、 `blk` という名前でProcオブジェクトとしてtriple内で利用できます。前回の内容を思い出してほしいのですが、Rubyでは全てがオブジェクトです。当然、 `blk` にもオブジェクトが代入されています。

代入されているのは、Procというクラスのインスタンスです。一旦は、 `do ~ end` 構文で作成されるコードブロックのオブジェクトだと覚えてください。そして、Procオブジェクトの内容を実行するためには、 `call` メソッドを呼び出します。

このとき、 `call` メソッドの引数として `acc` を渡していますが、これはブロック内の `|n|` に代入されます。
前回習ったように、Rubyでは最後に評価した式が戻り値として利用されます。つまり、この `blk.call(acc)` の戻り値は、`n + 1` です。戻り地が再度accに代入され、次のループを実行します。
